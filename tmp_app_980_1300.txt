      for (let i=0;i<boundaries.length-1;i++){
        const a = boundaries[i], b = boundaries[i+1];
        const seg = document.createElement('div');
        seg.className = 'timeline-segment' + (isWorkSegment(a,b)? '' : ' alt');
        seg.style.left = minutesToPct(a)+'%';
        seg.style.width = (minutesToPct(b)-minutesToPct(a))+'%';
        const label = document.createElement('div'); label.textContent = `${toHHMMOp(a)} - ${toHHMMOp(b)}`; seg.appendChild(label);
        trackEl.appendChild(seg);
      }
      for (let i=0;i<boundaries.length;i++){
        const locked = (i===0 || i===boundaries.length-1);
        const h = document.createElement('div'); h.className='timeline-handle' + (locked?' locked':'');
        h.style.left = minutesToPct(boundaries[i])+'%';
        if (!locked){ h.addEventListener('pointerdown', (e)=>startDrag(e,i)); }
        trackEl.appendChild(h);
      }
    }
    function startDrag(e, idx){
      e.preventDefault(); const rect = trackEl.getBoundingClientRect();
      dragging = { index: idx, rect };
      try { trackEl.setPointerCapture(e.pointerId); } catch {}
      window.addEventListener('pointermove', onDrag);
      window.addEventListener('pointerup', endDrag, { once: true });
    }
    function onDrag(e){
      if (!dragging) return; const { index, rect } = dragging;
      let pct = ((e.clientX - rect.left) / rect.width) * 100;
      const minGap = 5; // minutes
      const leftBound = boundaries[index-1] + minGap;
      const rightBound = boundaries[index+1] - minGap;
      let min = Math.round((pct/100)*DAY_MIN_OP);
      min = Math.max(leftBound, Math.min(rightBound, min));
      boundaries[index] = min;
      const list = edgeMap[index] || [];
      list.forEach(({i,edge}) => {
        const id = edge === 'start' ? `sch-${day.day}-${i}-start` : `sch-${day.day}-${i}-end`;
        const input = document.getElementById(id);
        if (input) input.value = toHHMMOp(min);
        if (edge==='start') intervals[i].start = toHHMMOp(min); else intervals[i].end = toHHMMOp(min);
      });
      renderTrack();
    }
    function endDrag(){ dragging = null; rebuildEdgeMap(); }

    inputsWrap.addEventListener('input', () => {
      for (let i=0;i<n;i++){
        const s = qs(`#sch-${day.day}-${i}-start`)?.value || intervals[i].start;
        const e = qs(`#sch-${day.day}-${i}-end`)?.value || intervals[i].end;
        intervals[i] = { start: s, end: e };
      }
      boundaries = computeBoundaries(); rebuildEdgeMap(); renderTrack();
    });

    renderScale(); renderTrack();
    card.appendChild(inputsWrap);
    grid.appendChild(card);
  });
}

function saveScheduleFromModal(){
  const users = loadUsers(); const id = (typeof CURRENT_EDIT_USER !== 'undefined') ? CURRENT_EDIT_USER : '';
  const i = users.findIndex(u => u.id === id); if (i === -1) return;
  const n = parseInt(qs('#sch-count')?.value || '2', 10) === 4 ? 4 : 2;
  const days = DAYS_FA.map((d, idx) => {
    const intervals = [];
    for (let k=0;k<n;k++){
      const s = qs(`#sch-${idx}-${k}-start`)?.value || '09:00';
      const e = qs(`#sch-${idx}-${k}-end`)?.value || '13:00';
      intervals.push({ start: s, end: e });
    }
    return { day: idx, label: d, intervals };
  });
  users[i].schedule = { type: n, days };
  saveUsers(users);
  document.body.style.overflow = '';
  qs('#schedule-modal')?.classList.add('hidden');
}

// Archive helpers and enhanced users table
const USERS_ARCHIVE_KEY = 'gamenet_users_archive';
function loadArchivedUsers(){ try { return JSON.parse(localStorage.getItem(USERS_ARCHIVE_KEY) || '[]'); } catch { return []; } }
function saveArchivedUsers(arr){ localStorage.setItem(USERS_ARCHIVE_KEY, JSON.stringify(arr)); }
function archiveAndRemoveUser(id){
  const users = loadUsers(); const idx = users.findIndex(u => u.id === id);
  if (idx === -1) return;
  const u = users[idx]; if (u.email) return; // don't remove admin
  const ok = confirm(`??? ????? «${(u.first||'')+' '+(u.last||'')}»? ????? ????? ??????.`);
  if (!ok) return;
  const arch = loadArchivedUsers(); arch.push({ ...u, archivedAt: new Date().toISOString() }); saveArchivedUsers(arch);
  users.splice(idx,1); saveUsers(users); renderUsers(); updateKpis();
}

// Override renderUsers to include role and delete action
(function(){
  const orig = typeof renderUsers === 'function' ? renderUsers : null;
  window.renderUsers = function(){
    const tbody = qs('#users-body'); if (!tbody) return; tbody.innerHTML = '';
    const headRow = qs('#tab-users thead tr');
    if (headRow) headRow.innerHTML = '<th>?? ? ????</th><th>??? ? ??? ????????</th><th>????? ????</th><th>???</th><th>?????</th><th>??????</th>';
    const users = loadUsers().filter(u => !u.email);
    users.forEach(u => {
      const tr = document.createElement('tr');
      const full = `${u.first || ''} ${u.last || ''}`.trim();
      const status = u.active ? '????' : '???????';
      const role = u.type === 'manager' ? '????? ????' : '?????';
      tr.innerHTML = `<td>${u.code || ''}</td><td>${full}</td><td>${u.phone || ''}</td><td>${role}</td><td>${status}</td><td>
        <button class="btn" data-act="edit" data-id="${u.id}">??????</button>
        <button class="btn" data-act="perm" data-id="${u.id}">?????????</button>
        <button class="btn danger" data-act="del" data-id="${u.id}">???</button>
      </td>`;
      tbody.appendChild(tr);
    });
    qsa('#users-body button[data-act]').forEach(b => b.addEventListener('click', () => {
      const id = b.getAttribute('data-id'); const act = b.getAttribute('data-act');
      if (act === 'edit') openUserModalX(id);
      if (act === 'perm') openPermModal(id);
      if (act === 'del') archiveAndRemoveUser(id);
    }));
  };
})();
